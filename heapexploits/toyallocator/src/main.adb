with Ada.Text_IO;
    use Ada.Text_IO;
with Ada.Integer_Text_IO;
    use Ada.Integer_Text_IO;

procedure Main is


   ----------- ALLOCATOR PROCEDURES -----------
   -- this is the array that the node holds
   type Index is range 0 .. 3;
   type Values is array (Index) of Integer;

   -- node object
   type Node;
   type Node_Ptr is access Node;
   type Node is record
        -- needs to be array of 4
        Data: Values;
        Id: Integer;
        Next: Node_Ptr;
   end record;

   -- procedure to allocate data
   -- request a node from the freelist to add to the storage pool
   -- in out?
   procedure Allocate(FreeList: in out Node_Ptr; StoragePool: in out Node_Ptr) is
      temp: Node_Ptr;
   begin
      -- check if free list has any available data to send to storage
      if FreeList = null then
         Ada.Text_IO.Put_Line("null, no storage left");

      else
         Ada.Text_IO.Put_Line("there is available memory");

         -- storage is empty
         -- cant call next because storage is empty itself...
         if StoragePool = null then
            Ada.Text_IO.Put_Line("storage pool is empty");


            --add to storage
            StoragePool := FreeList;


            -- if freelist only has 1
            if FreeList.Next = null then
               Ada.Text_IO.Put_Line("free list only has one val");
               --Ada.Integer_Text_IO.Put(FreeList.Id);
               FreeList := null;


            --otherwise remove first from freelist
            else
               Ada.Text_IO.Put_Line("remove first from freelist");
               FreeList := FreeList.Next;
            end if;


            --clean up storage pointers
            StoragePool.Next := null;

            -- storage already has some values
         else

            Ada.Text_IO.Put_Line("storage has data but lets add another");
            temp := StoragePool;

            StoragePool := FreeList;



            -- check if freelist has enough data
            if FreeList.Next = null then
               FreeList := null;
            else
               FreeList := FreeList.Next;
            end if;


            -- fix storage pointer

            StoragePool.Next := temp;


         end if;

      end if;
      -- if no, send error

      -- if yes:
      -- check if storage points to anything. if not, add to first
      -- else insert storage in order?

      -- make freelist nodes update to ignore the node that freelist allocated

      null;

   end Allocate;




   -- procedure to deallocate/free data
   -- start with linked list of 10 nodes. allocate pulls these from free list to storagepool
   -- free removes the node from the storagepool and returns to freelist
   -- in order?
   procedure Free is
   begin
      null;
   end Free;



   -- source: https://stackoverflow.com/questions/26682057/link-list-in-ada
   procedure Append_Node(InputVals: Values; Id: Integer; New_Node: in out Node_Ptr) is
    begin
      if New_Node = null then
        New_Node := new Node'(InputVals, Id, null);
        Ada.Text_IO.Put("Adding Head node");
        Ada.Text_IO.New_Line;
      else
        if New_Node.Next /= null then
          Append_Node(InputVals, Id, New_Node.Next);
        else
          Ada.Text_IO.Put("Adding Next node");
          Ada.Text_IO.New_Line;
          New_Node.Next := new Node'(InputVals, Id, null);
        end if;
      end if;
   end Append_Node;










   ----------- PRINTING/DISPLAY PROCEDURES --------------
   procedure PrintNode is
   begin
      null;
   end PrintNode;

   procedure Print_List(Node: in Node_Ptr) is
      --type Index2 is range 0 .. 3;
      Counter: Index := 0;
      OutsideCounter: Integer := 0;
    begin
      if Node /= null then
         -- print the node
         Ada.Text_IO.Put("ID: ");
         Ada.Integer_Text_IO.Put(Node.Id);
         Ada.Text_IO.Put("     [");
         for I in Node.Data'Range loop
            if Node.Data(I) /= 0 then
               Ada.Integer_Text_IO.Put(Node.Data(I));
            end if;
         end loop;
         Ada.Text_IO.Put("]");
         Ada.Text_IO.New_Line;

         --print using recursion
         Print_List(Node.Next);
      end if;
   end Print_List;


   procedure PrintStorage is
   begin
      null;
   end PrintStorage;

   procedure PrintFree is
   begin
      null;
   end PrintFree;






   ----------- HEAP STUFF ----------------
   StoragePool : Node_Ptr := null;
   FreeList : Node_Ptr := null;



   temp1: Values := (1,1,1,1);
   temp2: Values := (2,2,2,2);
   temp3: Values := (3,3,3,3);
   temp4: Values := (4,4,4,4);
   temp5: Values := (5,5,5,5);
begin
   -- add stuff to the free list
   Append_Node(temp1, 1, FreeList);
   Append_Node(temp2, 2, FreeList);
   Append_Node(temp3, 3, FreeList);
   --Append_Node(temp4, 4, FreeList);
   --Append_Node(temp5, 5, FreeList);

   Ada.Text_IO.Put_Line("FreeList:");
   Print_List(FreeList);
   Ada.Text_IO.Put_Line("Storage:");
   Print_List(StoragePool);


   -- Ada.Text_IO.Put_Line("Allocating data to Storage Pool");
   Ada.Text_IO.Put_Line("Allocate");
   Allocate(FreeList, StoragePool);
   Allocate(FreeList, StoragePool);
   Allocate(FreeList, StoragePool);

   Ada.Text_IO.Put_Line("FreeList:");
   Print_List(FreeList);
   Ada.Text_IO.Put_Line("Storage:");
   Print_List(StoragePool);


   Ada.Text_IO.Put_Line("Deallocate");
   Allocate(StoragePool, FreeList);

   Ada.Text_IO.Put_Line("FreeList:");
   Print_List(FreeList);
   Ada.Text_IO.Put_Line("Storage:");
   Print_List(StoragePool);


end Main;
