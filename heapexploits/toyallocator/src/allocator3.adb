with Ada.Text_IO;
with Ada.Integer_Text_IO;

procedure allocator3 is
   pragma Suppress_All;
   
   type Index is range 0 .. 3;
   type Values is array (Index) of Integer;

   -- node object
   type Node;
   type Node_Ptr is access all Node; -- cant aliased this, nneed subtype indication
   type Node is record
        -- needs to be array of 4
        Data: Values;
        Id: aliased Integer;
        Next: aliased Node_Ptr;
   end record;
   
   -- put the variables BEFORE the procedures to make them global!
   -- setup
   type Size is range 0 .. 15;
   type Global_Memory is array (Size) of aliased Node;
   --globals:
   Memory :  aliased Global_Memory;
   Free_List : aliased Node_Ptr;
   -- a place to store data:
   In_Use: aliased Global_Memory;
   SizeIndex: Size := 0;
   
   -- initialize memory
   procedure Init is 
      --X : aliased Node := Node'(100, null);
      TempInt : Integer := 0;
      Temp : Values := (TempInt, TempInt, TempInt, TempInt);
      Spam : Values := (-1, -1, -1, -1);
   begin
      --Memory(0) := X;
      Free_List := Memory(0)'Unchecked_Access;
      
      for I in (Size) loop
         --   Memory(I) := Node'(Temp, TempInt, null);
         
         -- init pointers
         if I < Size'Last then
            Memory(I).Next := Memory(I+1)'Unchecked_Access;
         else
            -- for last value of array
            Memory(I).Next := null;
         end if;
         
         -- init values
         Memory(I).Id := TempInt;
         Memory(I).Data := Temp;
         TempInt := TempInt + 1;
         Temp := (TempInt, TempInt, TempInt, TempInt);
      end loop;
-- fill in_use with -1s
      for I in (Size) loop
         In_Use(I).Id := -1;
         In_Use(I).Data := Spam;
         end loop;
      
      
   end Init;
   
  
      
   
   procedure AllocationA(Return_To_User: out Node_Ptr) is
      
   begin
      -- put that value in array and increment index
      In_Use(SizeIndex).Id := Return_To_User.Id;
      In_Use(SizeIndex).Data := Return_To_User.Data;
      SizeIndex := SizeIndex + 1;
      if Return_To_User /= null then
         Return_To_User := Return_To_User.Next;
        
      end if;

   end AllocationA;
   
   procedure Free(Given_Back: in Node_Ptr) is
      
   begin
      SizeIndex := SizeIndex -1;
      Given_Back.Next := Free_List;
      Free_List := Given_Back;
   end Free;
   
   procedure ChangeData(Node_Index: in Size; Node_Data_Index: in Index; ChangeVal: in Integer) is 
   begin
      In_Use(Node_Index).Data(Node_Data_Index) := ChangeVal;
   end ChangeData;
   
    procedure ReadNode(Node_Index: in Size; Node_Data_Index: in Index) is      
   begin
      Ada.Integer_Text_IO.Put(In_Use(Node_Index).Data(Node_Data_Index)); 
      end ReadNode;
   
   
   -- visualizations
   
   procedure VisualizeArray(Input: in Global_Memory) is
     
   begin
       for I in (Size) loop        
         Ada.Text_IO.Put("[");
         Ada.Integer_Text_IO.Put(Input(I).Data(0));         
         Ada.Integer_Text_IO.Put(Input(I).Data(1));         
         Ada.Integer_Text_IO.Put(Input(I).Data(2));        
         Ada.Integer_Text_IO.Put(Input(I).Data(3));
         Ada.Text_IO.Put("]");
         Ada.Text_IO.Put_Line("");
      end loop;
      Ada.Text_IO.Put_Line("");
   end VisualizeArray;
   
    procedure VisualizeFreeListHelper(Head: in Node_Ptr) is
      
   begin
      Ada.Integer_Text_IO.Put(Head.Id);
      if Head.next /= null then     
         VisualizeFreeListHelper(Head.Next);      
      end if;
   end VisualizeFreeListHelper;
   
   procedure VisualizeFreeList(Head: in Node_Ptr) is
   begin
      
      if Head /= null then
         Ada.Text_IO.Put("List: ");
         VisualizeFreeListHelper(Head);
      end if;
      --Ada.Text_IO.Put("List: ");
      Ada.Text_IO.Put_Line("");
      end VisualizeFreeList;
    
   
   
      
begin
   Init;
   VisualizeArray(Memory);
   
   Ada.Text_IO.Put_Line("");
   -- USE AFTER FREE
   -- A, allocate
   AllocationA(Free_List);
   
   -- B 0 0 23 , change the value
   ChangeData(0, 0, 23);
   
   -- C, free, hardcode 
   Free(In_Use(0)'Unchecked_Access);
   
   -- A, allocate
   AllocationA(Free_List);
   
   -- D 0 0 should get 23, read a node
   Ada.Text_IO.Put_Line("Expect: 23");
   ReadNode(0, 0);
   Ada.Text_IO.Put_Line("");
   
   -- B 0 0 42 (use after free), change a value
   ChangeData(0, 0, 42);
   
   -- D 0 0 --data is now 42, read a node
   Ada.Text_IO.Put_Line("Expect: 42");
   ReadNode(0, 0);
   Ada.Text_IO.Put_Line("");
   
   --VisualizeFreeList(Free_List);
   --VisualizeArray(In_Use);
   
   
   -- old stuff:
 --  Ada.Text_IO.Put_Line("Free List Vis:");
 --  VisualizeFreeList(Free_List);

 --  AllocationA(Free_List);
 --  AllocationA(Free_List);
 --  AllocationA(Free_List);
 --  AllocationA(Free_List);
 --  AllocationA(Free_List); 
 ---  AllocationA(Free_List);
   
   --Free(Free_List, 4);
   
  -- Ada.Integer_Text_IO.Put(Free_List.Id);
   
   
  -- Ada.Text_IO.Put_Line("Free List Vis:");
  -- VisualizeFreeList(Free_List);
   --Ada.Integer_Text_IO.Put(In_Use(0).Id);
end allocator3;
