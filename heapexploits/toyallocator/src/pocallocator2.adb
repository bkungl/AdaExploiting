with Ada.Text_IO;
with Ada.Integer_Text_IO;
with Ada.Exceptions; use Ada.Exceptions;

procedure pocallocator2 is
   
   pragma Suppress_All;
   
   
   
   type Index is range 0 .. 3;
   type Values is array (Index) of Integer;

   -- node object
   type Node;
   type Node_Ptr is access all Node;
   type Node is record
        -- needs to be array of 4
        Data: Values;
        Id: Integer;
        Next: Node_Ptr;
   end record;
   
   -- global free list
   Free_List : aliased Node_Ptr;
   
   -- global memory 
   type Size is range 0 .. 15;
   type Memory is array (Size) of aliased Node;
   Global_Mem : aliased Memory;
   
   procedure Append_Node(InputVals: Values; Id: Integer; New_Node: in out Node_Ptr) is
    begin
      if New_Node = null then
        New_Node := new Node'(InputVals, Id, null);
        Ada.Text_IO.Put("Adding Head node");
        Ada.Text_IO.New_Line;
      else
        if New_Node.Next /= null then
          Append_Node(InputVals, Id, New_Node.Next);
        else
          Ada.Text_IO.Put("Adding Next node");
          Ada.Text_IO.New_Line;
          New_Node.Next := new Node'(InputVals, Id, null);
        end if;
      end if;
   end Append_Node;
   
   
   -- set up global memory
   procedure Initialize is  
      
      
      
      TempInt : Integer := 0;
      Temp : Values := (TempInt, TempInt, TempInt, TempInt);
      --X : aliased Node;
   begin
      
      for I in (Size) loop
         Global_Mem(I) := Node'(Temp, TempInt, null);
         TempInt := TempInt + 1;
         Temp := (TempInt, TempInt, TempInt, TempInt);
      end loop;
      
      for J in (Size) loop
         if J < Size'Last then
            Global_Mem(J).Next := Global_Mem(J+1)'Unchecked_Access;
            --Ada.Integer_Text_IO.Put(Global_Mem(J).Id);
         end if;
      end loop;
      
   end Initialize;
   
   -- A, function Allocate return Node;
   function Allocate(TempReturn: in out Node) return Node is
      
   begin
      Ada.Text_IO.Put_Line("1");
      TempReturn := Node'(Free_List.Data, Free_List.Id, Free_List.Next);
      Ada.Text_IO.Put_Line("2");
      if Free_List.Next /= null then 
         Ada.Text_IO.Put_Line("3");
         Free_List := Free_List.Next;
      end if;
        Ada.Text_IO.Put_Line("4");
      return TempReturn;
   end Allocate;
   
  
   -- C, remove a value from utilized memory and return to free list   
   procedure Free(Given_Back: in Node_Ptr) is  
   begin
      Given_Back.Next := Free_List;
      Free_List := Given_Back;
   end Free;
   
   -- old:
    -- procedure for storing value in linked list
-- i dont use this anymore, just storing
   procedure AllocationLL(Stored: in out Node_Ptr; FL: in out Node_Ptr) is
      temp : Node_Ptr;
   begin
      if Stored = null then
         Stored := FL;
         if FL.Next /= null then
            FL := FL.Next;
         else 
            FL := null;
         end if;
         Stored.Next := null;
      else
         -- stored /= null
         temp := Stored;
         Stored := FL;
         if FL.Next /= null then
            FL := FL.Next;
         else 
            FL := null;
         end if;
         Stored.Next := temp;
      end if;  
      
   end AllocationLL;
   
   
   -- B, change a node's values array
   procedure ChangeData(Node_Index: in Size; Node_Data_Index: in Index; ChangeVal: in Integer) is 
   begin
      Global_Mem(Node_Index).Data(Node_Data_Index) := ChangeVal;
   end ChangeData;
   
   
   -- D, print a node
   procedure ReadNode(Node_Index: in Size; Node_Data_Index: in Index) is      
   begin
      Ada.Integer_Text_IO.Put(Global_Mem(Node_Index).Data(Node_Data_Index)); 
      end ReadNode;
   
  
   procedure VisualizeGlobalMemory is
     
   begin
       for I in (Size) loop        
         Ada.Text_IO.Put("[");
         Ada.Integer_Text_IO.Put(Global_Mem(I).Data(0));         
         Ada.Integer_Text_IO.Put(Global_Mem(I).Data(1));         
         Ada.Integer_Text_IO.Put(Global_Mem(I).Data(2));        
         Ada.Integer_Text_IO.Put(Global_Mem(I).Data(3));
         Ada.Text_IO.Put("]");
         Ada.Text_IO.Put_Line("");
      end loop;
      Ada.Text_IO.Put_Line("");
   end VisualizeGlobalMemory;
  
      
   In_Use : aliased Memory;
   Temp0 : Values := (0, 0, 0, 0);
   Y : Node;
begin
   
   Initialize;
   VisualizeGlobalMemory;
  
   --works:
   --ChangeData(4, 1, 130);
   -- type Size is range 0 .. 15;
   --type Memory is array (Size) of aliased Node;
   --Global_Mem : aliased Memory;
   
   --fill in use
   --for I in (Size) loop
   --    In_Use(I) := Node'(Temp0, 0, null);
   --end loop;
   
   Y := Allocate(Global_Mem(0));
  
   --Free(In_Use);
   
   VisualizeGlobalMemory;
   
   --Ada.Integer_Text_IO.Put(Free_List.Id);
   --Ada.Integer_Text_IO.Put(Global_Mem(0).Next.Id);
   
   
 --  exception
  --when Error: EXCEPTION_ACCESS_VIOLATION =>
   -- Ada.Text_IO.Put ("Access Violation: ");
    --Put_Line (Exception_Name (Error));
    --Put (Exception_Message (Error));
  --when Error: others =>
   -- Ada.Text_IO.Put ("Something Else: ");
    --Put_Line (Exception_Information(Error));
--exception
 --     when others => Ada.Text_IO.Put_Line("oh dang");

end pocallocator2;
