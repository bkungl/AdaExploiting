## User-Defined Storage Pool ##
Unlike the System Storage Pool, user-defined storage pools (like the arena pool in this folder) require a maximum size at compile time. This is against the idea of dynamic memory, which requires an unkown amount of memory at compile time so allocates at run time. As a result, data in user-defined storage pools is placed on the stack instead of the heap as in the system pool. Attacks in this section look to use a mix of heap and stack attacks since the user-pools function like a heap (in some, not all, ways) but are placed on the stack. 

There is a greater push to exploit stack registers in this section so GDB, assembly code analysis, trying to overwrite the stack pointer, and stack-based attack vectors are more prevelant here. 


The following code uses the arena pool storage pool (source: rosetta code).
All exploit attempts will include arena_pools.ads and arena_pools.adb


### Compiler flags: ###
gnatmake -gnat95 -g -gnatp <file.adb>



### Notes ###
Currently, I am trying to corrupt the stack pointer. My method:
- Have one procedure that makes a storage pool of size 62. Make a few integer_ptrs and initialize them.
- Have a second procedure that makes a storage pool of size 20. I found that the stack pointer of procedure 2 can match the memory location of some of the integer_pts in proc 1.

I stored the memory addr of the proc1 ptr that matches the proc2 sp.

- In the scope of proc1, the ptr addr was for example 0xbffff010
- In the scope of proc2, the sp add was for example 0xbffff010
- In the scope of proc1, the global = ptr was 0xbffff010
- In the scope of proc2, the global was for exmaple 0xbffff048


Todo: Figure out why the global value changed where it pointedd to at the scope change.
