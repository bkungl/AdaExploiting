-- includes
with Ada.Text_IO;with Ada.Text_IO;
with Ada.Integer_Text_IO;
with System.Address_Image;

with Ada.Unchecked_Conversion;



-- main procedure
procedure pseudoallocator is
   
   -- suppress all 
   -- turns off all checks listed here: https://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Suppress
   pragma Suppress(All_Checks);
   pragma Suppress_All;
   pragma Suppress(Range_Check);
   
   -- set up the array to hold a node's data
   type Index is new Integer range 0 .. 3;
   type Values is array (Index) of Integer;
   
   type ExploitIndex is new Integer range 0 .. 100;
   

   -- node object
   type Node;
   type Node_Ptr is access all Node;
   type Node is record
        Data: aliased Values;
        Id: aliased Integer;
        Next: aliased Node_Ptr;
   end record;
   
   -- put the variables BEFORE the procedures to make them global!
   -- for this example, pseudo memory is 16 chunks
   type Size is range 0 .. 15;
   type Global_Memory is array (Size) of aliased Node;
   
   ------------- globals: -----------------
   
   -- global memory
   Memory :  aliased Global_Memory;
   
   -- list to pointers of available memory
   Free_List : aliased Node_Ptr;
   
   -- a place to store data:
   type Used_Ptrs is array (Size) of aliased Node_Ptr;
   
   -- Array of pointers to in use memory
   In_Use: aliased Used_Ptrs;
   
   
   -- This value keeps track of the in_use array through allocation and free
   SizeIndex: Size := 0;
   
   -- Initialize memory
   procedure Init is 
      TempInt : Integer := 0;
      Temp : Values := (TempInt, TempInt, TempInt, TempInt);
   begin
      Free_List := Memory(0)'Unchecked_Access;
      
      for I in Size loop      
         -- Init pointers
         -- Although its an array, point the value to the next index 
         if I < Size'Last then
            Memory(I).Next := Memory(I+1)'Unchecked_Access;
         else
            -- For last value of array
            Memory(I).Next := null;
         end if;
         
         -- Init values
         Memory(I).Id := TempInt;
         Memory(I).Data := Temp;
         TempInt := TempInt + 1;
         Temp := (TempInt, TempInt, TempInt, TempInt);
         
         
         In_Use(I) := null;
      end loop;      
   end Init;
   
   -- Procedure to allocate memory from the free list to the in use array
   procedure malloc(Return_To_User: out Node_Ptr) is
      -- Type conversion to use the Integer: https://www.adaic.org/resources/add_content/standards/05rm/html/RM-4-6.html
      TempIndex : Size := Size(Free_List.Id);
   begin
      -- SizeIndex is used to set the correct spot of in use
      In_Use(TempIndex) := Free_List;
      
      -- If the free list has more memory, advance the head to head.next
      if Return_To_User /= null then         
         Return_To_User := Return_To_User.Next;
      end if;
   end malloc;
   
   -- Procedure to free memory from the in use array and return it to the free list
   procedure Free(Given_Back: in out Node_Ptr; Index: in Size) is
      Temp : Node_Ptr;
   begin
      Temp  := Given_Back;
      Given_Back := In_Use(Index);
      Given_Back.Next := Temp;
   
      -- set the pointer of in_use(index) to null
      In_Use(Index) := null;
      
   end Free;
   
   
   
   -- This procedure changes the data array of node
   -- NOTE: this procedure cannot, and should not, change the node.id
   procedure ChangeData(Node_Index: in Size; Node_Data_Index: in Index; ChangeVal: in Integer) is 
   begin
      In_Use(Node_Index).Data(Node_Data_Index) := ChangeVal;
   end ChangeData;
   
   
   -- This procedure reads an element from the Node.data array. Instead of the whole array being returned,
   -- only one value is.
   procedure ReadNode(Node_Index: in Size; Node_Data_Index: in Index) is      
   begin
      Ada.Integer_Text_IO.Put(In_Use(Node_Index).Data(Node_Data_Index)); 
   end ReadNode;
   
   -- This procedure prints the memory address of a node. This is used to generate Graphviz diagrams.
   procedure PrintPtr(n: in out Node_Ptr) is 
   begin 
      Ada.Text_IO.Put(" " & System.Address_Image(n.all'address));
   end PrintPtr; 
   
   
   -- This procedure is used to display the global memory array. The only importance of
   -- this is to make sure init worked properly, and when a node's data is changed it is changed
   -- in memory, not just at the in_use level.
   procedure VisualizeArray(Input: in Global_Memory) is    
   begin
       for I in Size loop        
         Ada.Text_IO.Put("[");
         Ada.Integer_Text_IO.Put(Input(I).Data(0));         
         Ada.Integer_Text_IO.Put(Input(I).Data(1));         
         Ada.Integer_Text_IO.Put(Input(I).Data(2));        
         Ada.Integer_Text_IO.Put(Input(I).Data(3));
         Ada.Text_IO.Put("]");
         --Ada.Text_IO.Put(" " & System.Address_Image(n.all'address));
         Ada.Text_IO.Put(" " & System.Address_Image(Input(I).Data'Address));
         Ada.Text_IO.Put_Line("");
      end loop;
      Ada.Text_IO.Put_Line("");
   end VisualizeArray;
   
   
   -- This procedure is a recursive helper function for printing a linked list
   procedure VisualizeFreeListHelper(Head: in out Node_Ptr) is      
   begin
      PrintPtr(Head);
      Ada.Integer_Text_IO.Put(Head.Id);
      if Head.next /= null then     
         VisualizeFreeListHelper(Head.Next);      
      end if;
   end VisualizeFreeListHelper;
   
   -- This procesure is the runner for printing a linked list.
   procedure VisualizeFreeList(Head: in out Node_Ptr) is
   begin
      
      if Head /= null then
         Ada.Text_IO.Put("List: ");
         VisualizeFreeListHelper(Head);
      end if;
      Ada.Text_IO.Put_Line("");
   end VisualizeFreeList;
   
   -- This procedure visualizes the in use memory, which is stored in an array
   -- Each element of the array points to a Node. 
   -- this should visualize an array of node pointers (not nodes)
   procedure VisualizeInUse is
   begin
      Ada.Text_IO.Put_Line("In Use:");

      -- only print the in_use node if it points to something other than null
      for I in Size loop
            if In_Use(I) /= null then
               Ada.Text_IO.Put("[");
               PrintPtr(In_Use(I));
               Ada.Integer_Text_IO.Put(In_Use(I).Id);
               Ada.Text_IO.Put("]");
               Ada.Text_IO.Put_Line("");
            end if;
       end loop;
      
   end VisualizeInUse; 
   
    function EIndex_to_Index is
      new Ada.Unchecked_Conversion (Source => ExploitIndex,
                                    Target => Index);
   
   
      
   addr : System.Address;
   testval : ExploitIndex; 
begin
   
   -- Example setup of allocating and freeing some memory and seeing the addresses 
   
   Init;
   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
   malloc(Free_List);
   malloc(Free_List);
   malloc(Free_List);
  
   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
   ChangeData(0, 3, 27895734);
   
   addr := Memory(1).Data(0)'Address;
   Ada.Text_IO.Put_Line("1 is " & System.Address_Image(addr));
   

   Ada.Integer_Text_IO.Put(Memory(8).Data(2));
   
   
   testval := 19;
   Ada.Text_IO.Put_Line(" " & Index'Image(EIndex_to_Index(testval)));
   ChangeData(0, EIndex_to_Index(testval), 9999);

   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
end pseudoallocator;

