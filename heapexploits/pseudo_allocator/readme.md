# Pseudo-Allocator

## Rationale
The pseudo-allocator is exactly as it sounds: a testing environment that falsely represents dynamic memory (the actualy variables in the program are gloabl instead of dynamic). The purpose of this section is to develop a memory allocation simulator. When a programmer indicates the need for dynamic memory using new, there are various under the hood features that are invisible to the programmer. These include Ada's new calling C's malloc, which in turn calls the OS kernel's mmap function. 

The pseudo-allocator gives the ability to create proof of concept attacks against "dynamic memory" (it's not dynamic here) without having to worry about under the hood implementations and Ada's compile and run time checks that make Ada incredibly safe from attack. 


## Layout

#### Global Array of Nodes
* Global Memory
* Each index holds a Node with the following attributes:
	* ID 
	* Data Array [ID, ID, ID, ID]
	* Next Pointer
	
#### Free List
* "A free list is a data structure used in a scheme for dynamic memory allocation. It operates by connecting unallocated regions of memory together in a linked list, using the first word of each unallocated region as a pointer to the next."
* The free list holds pointers to all the Nodes in Global Memory that are not currently being used by the program. When malloc is called, a node pointer from the free list is called. When free is called, a node pointer from in use is placed on the free list.

#### In Use Memory
* When memory is requested from the allocator's malloc function, it is stored in an array of pointers to Nodes. So where the Global Memory is an array of Nodes, the In Use Memory is an array of Node Pointers. 
* This array works in tandem with the free list. When a function is called, its data is placed or removed from the free list and in use memory. 

#### Allocate Function; Inputs: Pointer to the Free_List's head
Go to free list. If null, there's no memory available. If not, return the pointer to the head and move the pointer to the next.  

#### Deallocate Function (Free); Inputs: Pointer to the Free_List's Head and index of In_Use to set to null.
Take a value from the In Use array and place it on the free list at the head. Then make the index of In_Use point to null.

#### Init
This procedure establishes global memory by giving each index of the Global Memory Array a Node with incremented ID's. Then, it uses the array indicies to point nodes 0-memory.length-1 to the next element in Global Memory. Finally, establish an In_Use array of matching size to Global Memory and set each index's pointer to null. 

#### ChangeData; Inputs: Index of Memory to change, Index of Value of Memory.Data to change, Value to change to 
This procedure changes the global memory's data inside one of its data arrays.

#### ReadNode; Inputs: Index of Node to Read, Index of Node.Data array to Read
This procedure prints the current value of Memory(Index).Data(Index2).

## Resources
[Free List Allocator](https://github.com/mtrebi/memory-allocators#free-list-allocator)

[Rust Allocators](https://os.phil-opp.com/allocator-designs/#linked-list-allocator)
