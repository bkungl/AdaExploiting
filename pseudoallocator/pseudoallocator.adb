-- includes
with Ada.Text_IO;with Ada.Text_IO;
with Ada.Integer_Text_IO;
with System.Address_Image;

-- main procedure
procedure pseudoallocator is
   
   -- suppress all 
   -- turns off all checks listed here: https://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Suppress
   pragma Suppress (All_Checks);
   
   -- set up the array to hold a node's data
   type Index is range 0 .. 3;
   type Values is array (Index) of Integer;

   -- node object
   type Node;
   type Node_Ptr is access all Node;
   type Node is record
        Data: aliased Values;
        Id: aliased Integer;
        Next: aliased Node_Ptr;
   end record;
   
   -- put the variables BEFORE the procedures to make them global!
   -- for this example, pseudo memory is 16 chunks
   type Size is range 0 .. 15;
   type Global_Memory is array (Size) of aliased Node;
   
   ------------- globals: -----------------
   
   -- global memory
   Memory :  aliased Global_Memory;
   
   -- list to pointers of available memory
   Free_List : aliased Node_Ptr;
   
   -- a place to store data:
   type Used_Ptrs is array (Size) of aliased Node_Ptr;
   
   -- Array of pointers to in use memory
   In_Use: aliased Used_Ptrs;
   
   
   -- This value keeps track of the in_use array through allocation and free
   SizeIndex: Size := 0;
   
   -- Initialize memory
   procedure Init is 
      TempInt : Integer := 0;
      Temp : Values := (TempInt, TempInt, TempInt, TempInt);
   begin
      Free_List := Memory(0)'Unchecked_Access;
      
      for I in (Size) loop      
         -- Init pointers
         -- Although its an array, point the value to the next index 
         if I < Size'Last then
            Memory(I).Next := Memory(I+1)'Unchecked_Access;
         else
            -- For last value of array
            Memory(I).Next := null;
         end if;
         
         -- Init values
         Memory(I).Id := TempInt;
         Memory(I).Data := Temp;
         TempInt := TempInt + 1;
         Temp := (TempInt, TempInt, TempInt, TempInt);
      end loop;      
   end Init;
   
   -- Procedure to allocate memory from the free list to the in use array
   procedure malloc(Return_To_User: out Node_Ptr) is
   begin
      -- SizeIndex is used to set the correct spot of in use
      In_Use(SizeIndex) := Free_List;
      SizeIndex := SizeIndex + 1;
      
      -- If the free list has more memory, advance the head to head.next
      if Return_To_User /= null then         
         Return_To_User := Return_To_User.Next;
      end if;
   end malloc;
   
   -- Procedure to free memory from the in use array and return it to the free list
   procedure Free(Given_Back: in out Node_Ptr; Index: in Size) is
      Temp : Node_Ptr;
   begin
      Temp  := Given_Back;
      Given_Back := In_Use(Index);
      Given_Back.Next := Temp;
      
      -- Update size index
      -- NOTE: sizeindex is dangerous in the case of freeing a value that isnt the most recently allocated
      -- node in the in_use array. if 0, 1, and 2 are allocated and 1 is freed, size index becomes = 2.
      -- this is an issue because when allocate is called again, index 2 is allocated, but it has not been freed yet
      -- index 1 should be allocated instead. To fix this, sizeindex should be dropped, and indexes should be filled by using the
      -- node id. the node id should not be changeable.
      SizeIndex := SizeIndex -1;
      In_Use(Index) := null;
      
   end Free;
   
   
   
   -- This procedure changes the data array of node
   -- NOTE: this procedure cannot, and should not, change the node.id
   procedure ChangeData(Node_Index: in Size; Node_Data_Index: in Index; ChangeVal: in Integer) is 
   begin
      In_Use(Node_Index).Data(Node_Data_Index) := ChangeVal;
   end ChangeData;
   
   
   -- This procedure reads an element from the Node.data array. Instead of the whole array being returned,
   -- only one value is.
   procedure ReadNode(Node_Index: in Size; Node_Data_Index: in Index) is      
   begin
      Ada.Integer_Text_IO.Put(In_Use(Node_Index).Data(Node_Data_Index)); 
   end ReadNode;
   
   -- This procedure prints the memory address of a node. This is used to generate Graphviz diagrams.
   procedure PrintPtr(n: in out Node_Ptr) is 
   begin 
      Ada.Text_IO.Put(" " & System.Address_Image(n.all'address));
   end PrintPtr; 
   
   
   -- This procedure is used to display the global memory array. The only importance of
   -- this is to make sure init worked properly, and when a node's data is changed it is changed
   -- in memory, not just at the in_use level.
   procedure VisualizeArray(Input: in Global_Memory) is    
   begin
       for I in (Size) loop        
         Ada.Text_IO.Put("[");
         Ada.Integer_Text_IO.Put(Input(I).Data(0));         
         Ada.Integer_Text_IO.Put(Input(I).Data(1));         
         Ada.Integer_Text_IO.Put(Input(I).Data(2));        
         Ada.Integer_Text_IO.Put(Input(I).Data(3));
         Ada.Text_IO.Put("]");
         Ada.Text_IO.Put_Line("");
      end loop;
      Ada.Text_IO.Put_Line("");
   end VisualizeArray;
   
   
   -- This procedure is a recursive helper function for printing a linked list
   procedure VisualizeFreeListHelper(Head: in out Node_Ptr) is      
   begin
      PrintPtr(Head);
      Ada.Integer_Text_IO.Put(Head.Id);
      if Head.next /= null then     
         VisualizeFreeListHelper(Head.Next);      
      end if;
   end VisualizeFreeListHelper;
   
   -- This procesure is the runner for printing a linked list.
   procedure VisualizeFreeList(Head: in out Node_Ptr) is
   begin
      
      if Head /= null then
         Ada.Text_IO.Put("List: ");
         VisualizeFreeListHelper(Head);
      end if;
      Ada.Text_IO.Put_Line("");
   end VisualizeFreeList;
   
   -- This procedure visualizes the in use memory, which is stored in an array
   -- Each element of the array points to a Node. 
   -- this should visualize an array of node pointers (not nodes)
   procedure VisualizeInUse is
   begin
      Ada.Text_IO.Put_Line("In Use:");
      if SizeIndex /= 0 then        
         for I in (Size) loop
            if I < SizeIndex then
               Ada.Text_IO.Put("[");
               PrintPtr(In_Use(I));
               Ada.Integer_Text_IO.Put(In_Use(I).Id);
               Ada.Text_IO.Put("]");
               Ada.Text_IO.Put_Line("");
            end if;
         end loop;
      else -- It's empty
         Ada.Text_IO.Put("[ ]");
         Ada.Text_IO.Put_Line("");
      end if;
   end VisualizeInUse; 
   
   
      
begin
   Init;
   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
   malloc(Free_List);
   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
   Free(Free_List, 0);
   
   VisualizeArray(Memory);
   VisualizeFreeList(Free_List);
   VisualizeInUse;
   
end pseudoallocator;

