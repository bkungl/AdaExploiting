# Toy Allocator

## Rationale
Many government standards for Ada prevent the use of dynamic memory and allocators. As a result, programmers often create their own pseudo allocators with pseudo dynamic memory. As a result, dynamic memory errors can be more prevalent for developers that use custom allocators.

The following code is a basic implementation of an allocator using linked lists. 

TODO add details/ find a non awful way to describe the above


## Layout

#### Global Linked List of Nodes
* "Active memory"
* Node record is:
	* ID 
	* Data Array [ID, ID, ID, ID]
	* Next Pointer
	
 #### Free List
* "A free list is a data structure used in a shceme for dynamic memory allocation. It operates by connecting unallocated regions of memory together in a linked list, using the first word of each unallocated region as a pointer to the next."
* "To free a region, one would just link it to the free list"
* "To allocate a region, one would remove a single region from the end of the free list and use it." 
* Point Free List to First Node
* A single linked list holding memory that is in the freed memory region.
* Points to Head Node.
* Head points to next unused (free) Node, etc. 

#### Allocate Function
* Go to free list. If null, there's no memory available. If not, move the pointer.  
* (See source): "When an allocation is requested, it searches in the linked list for a block where the data can fit. Then it removes the element from the linked list and places an allocation header (used on deallocations) right before the data."

#### Deallocate Function (Free)
* (See source): "On deallocations, we get back the allocation header to know the size of the block that we are going to free. Once we free it we insert it into the sorted linked list and we try to merge contiguous memory blocks together creating bigger blocks."

## Resources
[Free List Allocator](https://github.com/mtrebi/memory-allocators#free-list-allocator)

[Rust Allocators](https://os.phil-opp.com/allocator-designs/#linked-list-allocator)
